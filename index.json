[{"categories":null,"content":"hook 继承与原型链 - JavaScript | MDN (mozilla.org) this 指向问题：JS函数hook_愧怍小儿的博客-CSDN博客_hook js函数 函数 hook let btoa_bk = btoa; btoa = function(val){ console.log(val) debugger; return btoa_bk } (function () { function hook(object, attr) { var func = object[attr]; object[attr] = function () { console.log(\"hooked\", object, attr); var ret = func.apply(object, arguments); debugger; return ret; }; } hook(window, \"btoa\"); })(); 属性 hook Object.defineProperty：Object.defineProperty Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 // 例子 Object.defineProperty(docment, 'cookie', { set: function(val){ debugger; return val } }) 利用油猴脚本方式注入 TODO 利用控制台方式注入 TODO ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/hook/:0:0","tags":null,"title":"Hook","uri":"/koko.github.io/posts/javascript_reverse/hook/"},{"categories":null,"content":"JavaScript 逆向 😅😥👶😃🧥🐶🍏⚽️✂🈲🚗⌚️❤️🏁▶ 之学习总结 ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:0:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"},{"categories":null,"content":"常见加密、解密、调试手段 API 参数加密 发起请求时会校验附带的参数，如 token、sign等 Cookie 参数解密 cookie 由 JavaScript 动态生成 加密 ob 混淆 webpack worker async：异步调试 jsl 加速乐 sojsonv6 TLS 指纹 protobuf jsvmp wasm 瑞数 文字验证码 顶象 极验 数美 网易易盾 5秒盾 akamai 谷歌验证码 字体反爬 解密 hook AST ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:1:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"},{"categories":null,"content":"ob 混淆篇 官网：https://obfuscator.io/ ob 混淆是常见的一种混淆方式，关于介绍可以去百度或者官网了解 混淆前 function hi() { console.log(\"Hello World!\"); } hi(); 混淆后部分截图 如果是利用开源库进行混淆的 JS 可以用下面解混淆 Tsaiboss/decodeObfuscator: 免安装一键还原Obfuscator混淆过的代码 (github.com) 也可以利自行编写 AST 代码，这里暂时不展开讨论 ob混淆案例网址：51job、前程无忧 此网址的 cookie 设置了有效时间，打上 script 断点后很容易找到生成 cookie 的函数入口 可以发现 name 是一个固定的字符串我们可以定死，而 x 参数通过堆栈中得知 x = arg2 arg2 由 _0x23a392 得来，arg1 参数是由服务器发的固定字符串 为了方便我们看代码我们可以利用 decodeObfuscator 解混淆，解混淆前后 我们可以更清楚的去分析函数之间的关系 分析结束后就是扣代码的流程了，这里就不多赘述了，直接贴上运行结果 ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:2:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"},{"categories":null,"content":"webpack 篇 webpack 是前端打包常用手段，并不是加密手段，只是经过 webpack 打包的 js 对逆向有一定的影响 中文官网：概念 | webpack 中文网 (webpackjs.com) webpack 标识 !(function(e) { //分发器 function u(n) { ..... return e[n].call(t.exports, t, t.exports, u), t.l = !0, t.exports }({ // 模块 'test': function(){}, })); 经过 webpack 打包的代码一般长这样，由分发器和待加载的模块组成 案例网址：Scrape | Movie 通过抓包发现，数据接口由 token 值是经过加密的 经过查找堆栈可以发现加密函数入口，我们在此处下断点刷新页面，断住后单步调试跟进去 跟进去后我们就可以找到该分发器，然后将该分发器导出方便我们使用里面的模块 扣下来，将其他无用的函数注释掉，定义一个 window（当然什么变量都行只是我习惯了） var window = global; window._0x3ff111_ = _0x3ff111; //将分发器导出 扣完后可以测试一下该分发器有没有效果 接下来就是扣加密所需的模块了 比如在控制台输出 _0x2fa7bd[‘a’] 发现是这个函数，它所在的模块是 ‘7d92’ 将他整个扣下来，缺什么模块就扣什么 也可以直接全部复制下来，建议用到什么模块就扣什么模块。我偷个懒 调用模块还原加密逻辑 _0x2fa7bd 是由 “7d92” 模块加载来的 ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:3:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"},{"categories":null,"content":"worker 多线程调试篇 ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:4:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"},{"categories":null,"content":"JSL 加速乐篇 案例网址：国家信息安全漏洞共享平台 老规矩先抓包，看一下它是怎么一个操作 可以看到他是发送了三次请求才返回正常的页面，第一次请求 Set-Cookie: __jsluid_s ，经过第一次请求后，第二次请求带着第一次请求的 set-cookie 和加密出来的 __jsl_clearance_s 发送请求，最后一次请求带着再一次加密过后的 __jsl_clearance_s 返回要采集的数据 ok，我们打上 script 断点然后刷新页面 可以看见第一次请求 set-cookie 后会返回这一串 js 代码，发现这就是我们要找的 __jsl_clearance_s 我们继续步进，发现第二次 __jsl_clearance_s 的加密逻辑，这是一个经过 ob 混淆的加密代码，我们可以通过hook 或者解混淆来找到入口函数，由于这个混淆度比较低直接就能看出来set cookie 的位置 多调试几次就会发现它每次加密 __jsl_clearance_s 的加密算法不同，分别是 sha1 sha256 md5，需要把这三个文件抓出来，然后就可以进行扣代码了 ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:5:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"},{"categories":null,"content":"sojson 篇 sojsonv6 加密网址：https://www.jsjiami.com/ sojsonv6：sojsonv6调试案例 中国人民银行 通过第一次请求 set_cookie 了一个 wzws_cid，返回一串经过 sojsonv6 加密的 js 然后经过加密后带上 wzwschallenge 参数和 wzws_cid 这个cookie 在请求一次，然后又 set_cookie 了 wzws_cid 把 cookie 清空打上 script 断点，可以发现有这个明显的特征，这个文件就是加密 wzwschallenge 的文件 ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:6:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"},{"categories":null,"content":"async 异步篇 异步调试，不知道有没有 js 异步调试技巧的文章分享一下… (待补充) async：异步调试案例 aHR0cHM6Ly9tdXNpYy4xNjMuY29tLw== 登录（手机号-密码）：加密参数 encSecKey parmas 分析思路：输入手机号、密码、点击登录 可以看见该 post 请求下面有两个加密参数 params 和 encSecKey 查看堆栈打上断点进入调试 打上断点之后我们可以看见参数 d 通过观察可以发现 d 这个参数是 b 这个包的加密参数 d 点击该按钮跳过该断点时出现 params 然后我们查看堆栈，发现在进入这个 g.asrsea 这个函数时 params 参数生成 且 g.asrsea 这个函数传入 f 这个值，f 里面包含了 手机号、密码、和一个 checktoken 这几个关键信息 单步调试跟进去，发现加密函数，此时 password 和 checktoken 是未知的 重新点击登录，重新打上断点，刚刚我们是在 f 这里我们继续往下看，找到 checktoken 和 password 的生成方式 当我们找到 m.ia 时我们可以看到 checktoken 是 dc 这个函数通过 r 和 x 参数加密得来 而 r 参数 由 bc 这个函数得来，至此就差 password 加密了 和上面一样继续找堆栈就可以发现 password 是由 MD5 加密得来 ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:7:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"},{"categories":null,"content":"TLS 指纹 TLS 及其前身 SSL 用于为常见应用程序和恶意软件加密通信，以确保数据安全，因此可以隐藏在噪音中。要启动 TLS 会话，客户端将在 TCP 3 次握手之后发送 TLS 客户端 Hello 数据包。此数据包及其生成方式取决于构建客户 端应用程序时使用的包和方法。服务器如果接受 TLS 连接，将使用基于服务器端库和配置以及 Client Hello 中的详 细信息制定的 TLS Server Hello 数据包进行响应。由于 TLS 协商以明文形式传输，因此可以使用 TLS Client Hello 数据包中的详细信息来指纹和识别客户端应用程序 ja3：JA3 is a standard for creating SSL client fingerprints in an easy to produce and shareable way TLS Fingerprinting with JA3 and JA3S | by John Althouse | Salesforce Engineering 推荐文章：深度剖析ja3指纹及突破 大佬文章里说的很详细 ja3指纹补充说明 ","date":"2022-05-16","objectID":"/koko.github.io/posts/javascript_reverse/readme/:8:0","tags":null,"title":"JavaScript 逆向","uri":"/koko.github.io/posts/javascript_reverse/readme/"}]